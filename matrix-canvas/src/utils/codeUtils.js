// Utility functions for color conversion and code generation

export const rgbToValue = (r, g, b) => {
  return (r << 5) | (g << 2) | b;
};

export const valueToRgb = (val) => {
  return {
    r: (val >> 5) & 0x7,
    g: (val >> 2) & 0x7,
    b: val & 0x3
  };
};

export const rgbToHex = (r, g, b) => {
  const rVal = Math.floor((r / 7) * 255);
  const gVal = Math.floor((g / 7) * 255);
  const bVal = Math.floor((b / 3) * 255);
  return `rgb(${rVal}, ${gVal}, ${bVal})`;
};

export const hexToClosestRgb = (hexColor) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColor);
  if (!result) return { r: 7, g: 7, b: 3 };
  
  const r255 = parseInt(result[1], 16);
  const g255 = parseInt(result[2], 16);
  const b255 = parseInt(result[3], 16);
  
  const r = Math.round((r255 / 255) * 7);
  const g = Math.round((g255 / 255) * 7);
  const b = Math.round((b255 / 255) * 3);
  
  return { r, g, b };
};

export const generateCode = (grid, selectedRegister, colorRegister, useDefW, optimizeCode) => {
  let code = "; STUMP LED Matrix Code\n";
  code += "; Generated by STUMP LED Matrix Code Generator\n\n";

  if (useDefW) {
    code += "; Base address for LED matrix\n";
    code += "LED_BASE DEFW 0xFF00\n\n";
  }

  const pixelsToSet = [];
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      if (grid[row][col] !== null) {
        const addr = 0xFF00 + (row * 8) + col;
        pixelsToSet.push({ addr, color: grid[row][col], row, col });
      }
    }
  }

  if (pixelsToSet.length === 0) {
    return code + "; No pixels set\n";
  }

  if (optimizeCode) {
    const colorGroups = {};
    pixelsToSet.forEach(pixel => {
      if (!colorGroups[pixel.color]) {
        colorGroups[pixel.color] = [];
      }
      colorGroups[pixel.color].push(pixel);
    });

    const colors = Object.keys(colorGroups).map(Number);
    
    if (useDefW && colors.length > 1) {
      code += "; Color definitions\n";
      colors.forEach((color, idx) => {
        code += `COLOR${idx} DEFW 0x${color.toString(16).padStart(2, '0').toUpperCase()}\n`;
      });
      code += "\n";
    }

    code += "; Set LED pixels\n";
    colors.forEach((color, idx) => {
      const pixels = colorGroups[color];
      
      if (useDefW && colors.length > 1) {
        code += `LD ${colorRegister}, COLOR${idx}\n`;
      } else {
        code += `LD ${colorRegister}, #0x${color.toString(16).padStart(2, '0').toUpperCase()}\n`;
      }

      pixels.forEach(pixel => {
        if (useDefW) {
          code += `LD ${selectedRegister}, LED_BASE\n`;
          if (pixel.addr !== 0xFF00) {
            const offset = pixel.addr - 0xFF00;
            code += `ADD ${selectedRegister}, ${selectedRegister}, #${offset}\n`;
          }
        } else {
          code += `LD ${selectedRegister}, #0x${pixel.addr.toString(16).toUpperCase()}\n`;
        }
        code += `ST ${colorRegister}, [${selectedRegister}]\n`;
      });
      code += "\n";
    });
  } else {
    if (useDefW) {
      code += "; Color and address definitions\n";
      pixelsToSet.forEach((pixel, idx) => {
        code += `LED${idx} DEFW 0x${pixel.addr.toString(16).toUpperCase()}\n`;
        code += `COLOR${idx} DEFW 0x${pixel.color.toString(16).padStart(2, '0').toUpperCase()}\n`;
      });
      code += "\n";
    }

    code += "; Set LED pixels\n";
    pixelsToSet.forEach((pixel, idx) => {
      if (useDefW) {
        code += `LD ${selectedRegister}, LED${idx}\n`;
        code += `LD ${colorRegister}, COLOR${idx}\n`;
      } else {
        code += `LD ${selectedRegister}, #0x${pixel.addr.toString(16).toUpperCase()}\n`;
        code += `LD ${colorRegister}, #0x${pixel.color.toString(16).padStart(2, '0').toUpperCase()}\n`;
      }
      code += `ST ${colorRegister}, [${selectedRegister}]\n\n`;
    });
  }

  return code;
};
