// Utility functions for color conversion and code generation

export const rgbToValue = (r, g, b) => {
  return (r << 5) | (g << 2) | b;
};

export const valueToRgb = (val) => {
  return {
    r: (val >> 5) & 0x7,
    g: (val >> 2) & 0x7,
    b: val & 0x3
  };
};

export const rgbToHex = (r, g, b) => {
  const rVal = Math.floor((r / 7) * 255);
  const gVal = Math.floor((g / 7) * 255);
  const bVal = Math.floor((b / 3) * 255);
  return `rgb(${rVal}, ${gVal}, ${bVal})`;
};

export const hexToClosestRgb = (hexColor) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColor);
  if (!result) return { r: 7, g: 7, b: 3 };

  const r255 = parseInt(result[1], 16);
  const g255 = parseInt(result[2], 16);
  const b255 = parseInt(result[3], 16);

  const r = Math.round((r255 / 255) * 7);
  const g = Math.round((g255 / 255) * 7);
  const b = Math.round((b255 / 255) * 3);

  return { r, g, b };
};

/**
 * Helper: Get approximate color name from RGB values
 */
const getColorName = (colorValue) => {
  const { r, g, b } = valueToRgb(colorValue);

  // Check for grayscale
  if (r === g && g === (b === 3 ? 7 : b * 2)) {
    if (r === 0) return "Black";
    if (r === 7) return "White";
    return "Gray";
  }

  // Primary and secondary colors
  if (r === 7 && g === 0 && b === 0) return "Red";
  if (r === 0 && g === 7 && b === 0) return "Green";
  if (r === 0 && g === 0 && b === 3) return "Blue";
  if (r === 7 && g === 7 && b === 0) return "Yellow";
  if (r === 7 && g === 0 && b === 3) return "Magenta";
  if (r === 0 && g === 7 && b === 3) return "Cyan";
  if (r === 7 && g === 7 && b === 3) return "White";
  if (r === 0 && g === 0 && b === 0) return "Black";

  // Approximate color names based on dominant component
  const dominant = Math.max(r, g, b === 3 ? 7 : b * 2);
  const colors = [];

  if (r >= dominant * 0.7) colors.push("Red");
  if (g >= dominant * 0.7) colors.push("Green");
  if (b >= (b === 3 ? 7 : 3) * 0.7) colors.push("Blue");

  if (colors.length === 0) return "Dark";
  if (colors.length === 3) return "Light";
  if (colors.length === 2) {
    if (colors.includes("Red") && colors.includes("Green")) return "Yellow-ish";
    if (colors.includes("Red") && colors.includes("Blue")) return "Magenta-ish";
    if (colors.includes("Green") && colors.includes("Blue")) return "Cyan-ish";
  }

  return colors[0] + "-ish";
};

/**
 * Helper: Generate optimized code (Lookup Table strategy - Max 8 colors)
 */
const generateOptimizedCode = (colorGroups, R_ADDR, R_COLOR, R_PTR, dataKeyword) => {
  const codeLines = [];
  const colors = Object.keys(colorGroups).map(Number).sort((a, b) => a - b);
  const colorMap = new Map();

  // Build Code Section
  codeLines.push("; STUMP LED Matrix Code - Optimized Mode");
  codeLines.push("; Generated by STUMP LED Matrix Code Generator");
  codeLines.push(";");
  codeLines.push(`; Register Assignments`);
  codeLines.push(`; ${R_ADDR} = Pixel address register`);
  codeLines.push(`; ${R_COLOR} = Color value register`);
  codeLines.push(`; ${R_PTR} = Data table pointer`);
  codeLines.push("");
  codeLines.push("; ORG 0x0000    ; Suggested origin for code section");
  codeLines.push("");

  // Data table at the start (before code)
  codeLines.push("DATA_TABLE");

  // Add 8 row base addresses
  for (let i = 0; i < 8; i++) {
    const rowAddr = 0xFF00 + (i * 8);
    codeLines.push(`${dataKeyword} 0x${rowAddr.toString(16).toUpperCase()}    ; [${R_PTR}, #${i}] Row ${i} base`);
  }

  // Add color values
  let colorTableIndex = 8;
  for (const color of colors) {
    const colorName = getColorName(color);
    codeLines.push(`${dataKeyword} 0x${color.toString(16).padStart(4, '0').toUpperCase()}    ; [${R_PTR}, #${colorTableIndex}] ${colorName}`);
    colorMap.set(color, colorTableIndex);
    colorTableIndex++;
  }

  codeLines.push("");
  codeLines.push("MAIN_CODE");
  codeLines.push(`LD ${R_PTR}, [R7, #0]    ; Load DATA_TABLE address (PC-relative, PC already incremented)`);
  codeLines.push(`${dataKeyword} DATA_TABLE`);
  codeLines.push("");

  // Process each color group
  for (const color of colors) {
    const pixels = colorGroups[color];
    const tableIndex = colorMap.get(color);
    const colorHex = color.toString(16).padStart(4, '0').toUpperCase();
    const colorName = getColorName(color);

    codeLines.push(`; --- ${colorName} (0x${colorHex}) - ${pixels.length} pixel${pixels.length !== 1 ? 's' : ''} ---`);
    codeLines.push(`LD ${R_COLOR}, [${R_PTR}, #${tableIndex}]    ; Load color value`);

    for (const pixel of pixels) {
      codeLines.push(`LD ${R_ADDR}, [${R_PTR}, #${pixel.r}]    ; Get row ${pixel.r} base address`);
      codeLines.push(`ST ${R_COLOR}, [${R_ADDR}, #${pixel.c}]    ; Store color at (${pixel.r},${pixel.c})`);
    }
    codeLines.push("");
  }

  codeLines.push("END_PROGRAM");
  codeLines.push("B END_PROGRAM    ; Infinite loop");

  return codeLines.join('\n');
};/**
 * Helper: Generate unoptimized code (PC-Relative Data strategy - 64 color limit)
 */
const generateUnoptimizedCode = (allPixels, R_ADDR, R_COLOR, R_PTR, dataKeyword) => {
  const codeLines = [];

  // Build Code Section
  codeLines.push("; STUMP LED Matrix Code - Unoptimized Mode");
  codeLines.push("; Generated by STUMP LED Matrix Code Generator");
  codeLines.push(";");
  codeLines.push(`; Register Assignments`);
  codeLines.push(`; ${R_ADDR} = Pixel address register`);
  codeLines.push(`; ${R_COLOR} = Color value register`);
  codeLines.push(`; ${R_PTR} = Data table pointer`);
  codeLines.push("");
  codeLines.push("; ORG 0x0000    ; Suggested origin for code section");
  codeLines.push("");

  // Data table at the start (row addresses only)
  codeLines.push("DATA_TABLE");
  for (let i = 0; i < 8; i++) {
    const rowAddr = 0xFF00 + (i * 8);
    codeLines.push(`${dataKeyword} 0x${rowAddr.toString(16).toUpperCase()}    ; [${R_PTR}, #${i}] Row ${i} base`);
  }

  codeLines.push("");
  codeLines.push("MAIN_CODE");
  codeLines.push(`LD ${R_PTR}, [R7, #0]    ; Load DATA_TABLE address (PC-relative, PC already incremented)`);
  codeLines.push(`${dataKeyword} DATA_TABLE`);
  codeLines.push("");

  // Process each pixel individually
  for (const pixel of allPixels) {
    const colorHex = pixel.color.toString(16).padStart(4, '0').toUpperCase();
    const colorName = getColorName(pixel.color);

    codeLines.push(`; --- Pixel (${pixel.r},${pixel.c}) = ${colorName} (0x${colorHex}) ---`);
    codeLines.push(`LD ${R_ADDR}, [${R_PTR}, #${pixel.r}]    ; Get row ${pixel.r} base address`);
    codeLines.push(`LD ${R_COLOR}, [R7, #0]    ; Load color (PC-relative, PC already incremented)`);
    codeLines.push(`${dataKeyword} 0x${colorHex}    ; Color data`);
    codeLines.push(`ST ${R_COLOR}, [${R_ADDR}, #${pixel.c}]    ; Store color at (${pixel.r},${pixel.c})`);
    codeLines.push("");
  }

  codeLines.push("END_PROGRAM");
  codeLines.push("B END_PROGRAM    ; Infinite loop");

  return codeLines.join('\n');
};

/**
 * Main code generator (Dispatcher)
 * @param {Array<Array<number|null>>} grid - The 8x8 grid state
 * @param {string} selectedRegister - Address register (R1-R6)
 * @param {string} colorRegister - Color register (R1-R6)
 * @param {string} pointerRegister - Pointer register (R1-R6)
 * @param {string} dataKeyword - Either 'DEFW' or 'DATA'
 * @param {boolean} optimizeCode - Whether to use optimized mode (max 8 colors)
 * @returns {string} Generated STUMP assembly code
 */
export const generateCode = (grid, selectedRegister, colorRegister, pointerRegister, dataKeyword, optimizeCode) => {
  // Validate registers
  const allRegisters = ['R1', 'R2', 'R3', 'R4', 'R5', 'R6'];
  
  if (selectedRegister === colorRegister || selectedRegister === pointerRegister || colorRegister === pointerRegister) {
    return "; ERROR: Register conflict.\n; Please select three different registers for Address, Color, and Pointer.";
  }
  
  if (!allRegisters.includes(selectedRegister) || !allRegisters.includes(colorRegister) || !allRegisters.includes(pointerRegister)) {
    return "; ERROR: Invalid register selection.\n; Please select registers from R1-R6.";
  }
  
  // Analyze grid data
  const allPixels = [];
  const colorGroups = {};
  
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const color = grid[r][c];
      if (color !== null) {
        allPixels.push({ r, c, color });
        
        if (!colorGroups[color]) {
          colorGroups[color] = [];
        }
        colorGroups[color].push({ r, c });
      }
    }
  }
  
  // Handle empty grid
  if (allPixels.length === 0) {
    return "; STUMP LED Matrix Code\n; No pixels set\n";
  }
  
  // Dispatch based on optimization mode
  if (optimizeCode) {
    const uniqueColorCount = Object.keys(colorGroups).length;
    
    if (uniqueColorCount > 8) {
      return `; ERROR: Too many colors for optimized mode.\n;\n; Your design uses ${uniqueColorCount} unique colors.\n; Optimized mode supports a maximum of 8 colors.\n;\n; Please either:\n;   1. Reduce your design to 8 or fewer colors, OR\n;   2. Uncheck the "Optimize code" option to use unoptimized mode.\n;\n; Unoptimized mode supports up to 64 different colors.`;
    }
    
    return generateOptimizedCode(colorGroups, selectedRegister, colorRegister, pointerRegister, dataKeyword);
  } else {
    return generateUnoptimizedCode(allPixels, selectedRegister, colorRegister, pointerRegister, dataKeyword);
  }
};